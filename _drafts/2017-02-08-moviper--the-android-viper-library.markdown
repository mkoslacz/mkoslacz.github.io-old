---
layout: post
title: "Moviper - the Android VIPER Library"
date: "2017-02-08 08:38:09 +0100"
---

#tl;dr


On the previous post I have covered pros and cons and a general idea of the viper architecture. For now let's focus on Moviper - the Android Viper library. Moviper comes in many different flavors, you can choose more or less advanced one or just pick one that fits you most. In this post I'll show you the flavor I use in the daily basis on the example of a simple Github login screen. I use Rx Presenters, Passive Autoinject Views and I wrap it up using Kotlin language with Android Kotlin Extensions. Sounds scary? Actually it's pretty straighforward. Fear not and read on!

We are going to create very simple app, that will allow a user to log in to Github and go to the fake profile page, and provide info about the app.

INSERT SOME SCREENSHOTS

It will consist of login screen that:
- allows user to go to the help screen,
- lead to profile page after login.

Ok, enough talking, let's get our feet wet!

First of all, install the [Moviper Templates Generator](https://github.com/mkoslacz/MoviperTemplateGenerator) using instructions provided in the repos readme. Just click the link I've inlined. Remember to restart the Android Studio after the installation!

After that, start up with a brand new Android project with no Activity. If you're new to Android you can follow a official Google tutorial [here](https://developer.android.com/studio/projects/create-project.html) to learn more about stuff we will discuss here.

The next step is pretty obvious, go to [Moviper Github page](https://github.com/mkoslacz/Moviper) and find the latest Moviper version and import its dependency adding following line to app module gradle dependencies and sync the project.

```(groovy)
dependencies {
  compile 'com.mateuszkoslacz.moviper:moviper-rx:2.0.1'
}
```

Now things get interesting. Let's create our first Viper Activity! Right-click the app package and select New -> Moviper -> RxActivity (see attached screen). Pro tip: you can even assign a shortcut to creating any of the Moviper modules using *Manage shortcuts* menu (easy to find using our standard cmd/ctrl + shift + A magic) and searching for "moviper" actions. That will be even more smooth using the great [Key Promoter](https://plugins.jetbrains.com/plugin/4455-key-promoter) plugin, it will suggest you assigning a shortcut to the most used actions, you should definitely check it out. Pro tip: search for "plugins" menu using cmd shift a, and just search for this plugin there!

![This is where lies RxActivity generator.]({{ site.url }}/assets/chosingViperRxActivity.jpg){:.center-image}
*This is where lies RxActivity generator.*{: style="text-align: center; display: block;"}

![Assigning shortcuts for Moviper actions will definitely come in handy.]({{ site.url }}/assets/assigningShortcutsToMoviper.jpg){:.center-image}
*Assigning shortcuts for Moviper actions will definitely come in handy.*{: style="text-align: center; display: block;"}

Fill up the form like I did on the attached image: name it LoginActivity, mark it as a Launcher Activity and select Passive Autoinject type. There are some magic options there, but just trust me for now - I'll cover them later. After confirming that choice we land in the Contract class. It generally has the one purpose - it defines whole control and data flow in the given screen. At your left hand side, on the project overview, you can see the rest of the classes generated by plugin in \*.viper.login package. Viper is general package for viper modules, and login was inferred from the name we gave to the generated Activity. But hold on - I told you that we will make a Kotlin app, and these files feel somehow suspicious. Yep, MoviperTemplateGenerator creates only Java file sets and actually there is no plan to migrate it to Kotlin, as this way we can use it in the Java code, and for Kotlin apps we can convert it to Kotlin very easy, so let's do it right now using magic alt + cmd + shift + K shortcut in each of generated classes.

For now we have a set of 5 Kotlin files:

- LoginActivity class (the view)
- LoginContract interface
- LoginInteractor class
- LoginPresenter class
- LoginRouting class

It's a good time to stop now and discuss the responsibility distribution over these components. In a classical objc-viper we have a following division:

>The main parts of VIPER are:
>
>View: displays what it is told to by the Presenter and relays user input back to the Presenter.
>Interactor: contains the business logic as specified by a use case.
>Presenter: contains view logic for preparing content for display (as received from the Interactor) and for reacting to user inputs (by requesting new data from the Interactor).
>Entity: contains basic model objects used by the Interactor.
>Routing: contains navigation logic for describing which screens are shown in which order.

But in our team we have worked out the following, slightly shifted responsibility fragmentation:

- View: displays what it is told to by the Presenter and relays user input back to the Presenter. (exactly the same as above)
- Interactor: contains the data read/write logic - all of the api and db calls go here.
- Presenter: contains the buisness logic: reacts to user input, ie translating to interactor and routing calls, decides what to display on view, validates the data in the business sense.
- Entity: data objects that are used in the app buisness logic, independent from data handling and view implementation
- Routing: contains all system-related logic. You can alternatively call it "System". It manages navigation, screen transitions, scheduling notifications, etc.

Mentioned division allows us to create modular, testable, clean and neat code. So, now we know where to put our stuff, so let's begin to code!

The starting point of every screen is a contract. As I already mentioned, it defines whole and flow between modules of a screen. Let's define methods needed to implement the whole login screen:

```Java
interface LoginContract {

    interface View : MvpView {
        val loginClicks: Observable<LoginBundle>
        val helpClicks: Observable<Any>
        fun showLoading()
        fun hideLoading()
        fun showError(error: Throwable)
    }

    interface Interactor : ViperRxInteractor {
        fun performLogin(loginBundle: LoginBundle): Single<Any>
    }

    interface Routing : ViperRxRouting<Activity> {
        fun goToHelpScreen()
        fun goToLoginScreen()
    }
}

```

and `LoginBundle` used as a Observable event type:

```Java
data class LoginBundle(val login: String,
                       val password: String)
```


As you can see, Presenter has no interface here. Now we get to the Passive word from the used Moviper screen flavor. Passive Viper means that View has no idea about Presenter attached to it. Actually you can access presenter from view using `presenter` property / `getPresenter()` method, but in this flavor it will be just plain ViperPresenter, so you won't have an access to your actual presenter methods. View communicates with presenter through event streams exposed through view interface to which preseter subscribes when attaching to the view. Interactor and Routing are, let's say, Preseters "tools", presenter delegates work to them and receives results using Observables. That said, there is no component that calls Presenters methods, so there is no need to make it implement any interface.

Ok, so let's begin implementing the Presenter. Let's check out what do we have there already.

```Java
class LoginPresenter :
        BaseRxPresenter<LoginContract.View,
                LoginContract.Interactor,
                LoginContract.Routing>(),
        ViperPresenter<LoginContract.View> {

    override fun createRouting(): LoginContract.Routing = LoginRouting()

    override fun createInteractor(): LoginContract.Interactor = LoginInteractor()
}
```

As you can see, the class declaration is pretty complicated because of some crazy generic stuff. Don't worry, after implementing some Viper modules you will get what happens here, but for now just trust the force and begin with defining what shall happen on the very beginning of the presenter lifecycle in Viper module. To achieve that override the `attachView(view: LoginContract.View?)` method. Don't forget to call super!

```Java
class LoginPresenter :
        BaseRxPresenter<LoginContract.View,
                LoginContract.Interactor,
                LoginContract.Routing>(),
        ViperPresenter<LoginContract.View> {

    override fun attachView(view: LoginContract.View?) {
        super.attachView(view)

        addSubscription(
                view
                        ?.loginClicks
                        ?.doOnNext { view?.showLoading() }
                        ?.subscribeOn(Schedulers.io())
                        ?.flatMapSingle { interactor.performLogin(it) }
                        ?.observeOn(AndroidSchedulers.mainThread())
                        ?.doOnError {
                            view?.hideLoading()
                            view?.showError(it)
                        }
                        ?.retry()
                        ?.subscribe { routing.goToLoginScreen() })

        addSubscription(
                view
                        ?.helpClicks
                        ?.doOnError { view?.showError(it) }
                        ?.retry()
                        ?.subscribe { routing.goToHelpScreen() })
    }

    override fun createRouting(): LoginContract.Routing = LoginRouting()

    override fun createInteractor(): LoginContract.Interactor = LoginInteractor()
}
```

As you probably noticed, presenter has an access to view, routing and interactor in whole class scope. Moreover, it automagically cast it to appropriate interface defined in contract. Note that I always use the view optional call - it's just easier to do it in a no-brainer way, as we often use thread switching in our streams, so view could get detached from the presenter in the meanwhile. Don't let Android Studio fool you using "unnecessary safe call" message! On the other hand Interactor and Routing are tightly coupled with presenter so there is no need to use safe calls on them in any situation. The other fancy thing there is that we haven't even touched the another components but we can safely implement whole presenter! Using Moviper you can pararelize work on the single module on whole team. Making work more focused on single screen makes you send new builds to QA faster, so there is no bottlenecking on the very end of the sprint! Now let's go back to the implementation.
