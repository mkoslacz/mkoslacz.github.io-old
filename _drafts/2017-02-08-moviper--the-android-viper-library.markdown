---
layout: post
title: "Moviper - the Android VIPER Library"
date: "2017-02-08 08:38:09 +0100"
---

#tl;dr


On the previous post I have covered pros and cons and a general idea of the viper architecture. For now let's focus on Moviper - the Android Viper library. Moviper comes in many different flavors, you can choose more or less advanced one or just pick one that fits you most. In this post I'll show you the flavor I use in the daily basis on the example of a simple Github login screen. I use Rx Presenters, Passive Autoinject Views and I wrap it up using Kotlin language with Android Kotlin Extensions. Sounds scary? Actually it's pretty straighforward. Fear not and read on!

We are going to create very simple app, that will allow a user to log in to Github and go to the fake profile page, and provide info about the app.

INSERT SOME APP SCREENSHOTS

It will consist of login screen that:
- allows user to go to the help screen,
- lead to profile page after login.

Ok, enough talking, let's get our feet wet!

First of all, install the [Moviper Templates Generator](https://github.com/mkoslacz/MoviperTemplateGenerator) using instructions provided in the repos readme. Just click the link I've inlined. Remember to restart the Android Studio after the installation!

After that, start up with a brand new Android project with no Activity. If you're new to Android you can follow a official Google tutorial [here](https://developer.android.com/studio/projects/create-project.html) to learn more about stuff we will discuss here.

The next step is pretty obvious, go to [Moviper Github page](https://github.com/mkoslacz/Moviper) and find the latest Moviper version and import its dependency adding following line to app module gradle dependencies and sync the project.

```(groovy)
dependencies {
  compile 'com.mateuszkoslacz.moviper:moviper-rx:2.0.1'
}
```

Now things get interesting. Let's create our first Viper Activity! Right-click the app package and select New -> Moviper -> RxActivity (see attached screen). Pro tip: you can even assign a shortcut to creating any of the Moviper modules using *Manage shortcuts* menu (easy to find using our standard cmd/ctrl + shift + A magic) and searching for "moviper" actions. That will be even more smooth using the great [Key Promoter](https://plugins.jetbrains.com/plugin/4455-key-promoter) plugin, it will suggest you assigning a shortcut to the most used actions, you should definitely check it out. Pro tip: search for "plugins" menu using cmd shift a, and just search for this plugin there!

![This is where lies RxActivity generator.]({{ site.url }}/assets/chosingViperRxActivity.jpg){:.center-image}
*This is where lies RxActivity generator.*{: style="text-align: center; display: block;"}

![Assigning shortcuts for Moviper actions will definitely come in handy.]({{ site.url }}/assets/assigningShortcutsToMoviper.jpg){:.center-image}
*Assigning shortcuts for Moviper actions will definitely come in handy.*{: style="text-align: center; display: block;"}

Fill up the form like I did on the attached image: name it LoginActivity, mark it as a Launcher Activity and select Passive Autoinject type. There are some magic options there, but just trust me for now - I'll cover them later. After confirming that choice we land in the Contract class. It generally has the one purpose - it defines whole control and data flow in the given screen. At your left hand side, on the project overview, you can see the rest of the classes generated by plugin in \*.viper.login package. Viper is general package for viper modules, and login was inferred from the name we gave to the generated Activity. But hold on - I told you that we will make a Kotlin app, and these files feel somehow suspicious. Yep, MoviperTemplateGenerator creates only Java file sets and actually there is no plan to migrate it to Kotlin, as this way we can use it in the Java code, and for Kotlin apps we can convert it to Kotlin very easy, so let's do it right now using magic alt + cmd + shift + K shortcut in each of generated classes.

For now we have a set of 5 Kotlin files:

- LoginActivity class (the view)
- LoginContract interface
- LoginInteractor class
- LoginPresenter class
- LoginRouting class

It's a good time to stop now and discuss the responsibility distribution over these components. In a classical objc-viper we have a following division:

>The main parts of VIPER are:
>
>View: displays what it is told to by the Presenter and relays user input back to the Presenter.
>Interactor: contains the business logic as specified by a use case.
>Presenter: contains view logic for preparing content for display (as received from the Interactor) and for reacting to user inputs (by requesting new data from the Interactor).
>Entity: contains basic model objects used by the Interactor.
>Routing: contains navigation logic for describing which screens are shown in which order.

But in our team we have worked out the following, slightly shifted responsibility fragmentation:

- View: displays what it is told to by the Presenter and relays user input back to the Presenter. (exactly the same as above)
- Interactor: contains the data read/write logic - all of the api and db calls go here.
- Presenter: contains the buisness logic: reacts to user input, ie translating to interactor and routing calls, decides what to display on view, validates the data in the business sense.
- Entity: data objects that are used in the app buisness logic, independent from data handling and view implementation
- Routing: contains all system-related logic. You can alternatively call it "System". It manages navigation, screen transitions, scheduling notifications, etc.

Mentioned division allows us to create modular, testable, clean and neat code. So, now we know where to put our stuff, so let's begin to code!

The starting point of every screen is a contract. As I already mentioned, it defines whole and flow between modules of a screen. Let's define methods needed to implement the whole login screen:

```Java
interface LoginContract {

    interface View : MvpView {
        val loginClicks: Observable<LoginBundle>
        val helpClicks: Observable<Any>
        fun showLoading()
        fun hideLoading()
        fun showError(error: Throwable)
    }

    interface Interactor : ViperRxInteractor {
        fun performLogin(loginBundle: LoginBundle): Single<UserModel>
    }

    interface Routing : ViperRxRouting<Activity> {
        fun goToHelpScreen()
        fun goToProfileScreen()
    }
}

```

and `LoginBundle` data class used as a Observable event type that will, well, bundle the user login data. Let's put it to the `data` package:

```Java
data class LoginBundle(val login: String,
                       val password: String)
```

There is also a UserModel class that will represent our user retreived from the remote:

```Java
data class UserModel(val login: String,
                     val id: Int)
```

// TODO change it!
![Let's put our nice data class to the separate package.]({{ site.url }}/assets/LoginBundleLocation.png){:.center-image}
*Let's put our nice data class to the separate package.*{: style="text-align: center; display: block;"}

As you can see, Presenter has no interface here. Now we get to the Passive word from the used Moviper screen flavor. Passive Viper means that View has no idea about Presenter attached to it. Actually you can access presenter from view using `presenter` property / `getPresenter()` method, but in this flavor it will be just plain ViperPresenter, so you won't have an access to your actual presenter methods. View communicates with presenter through event streams exposed through view interface to which preseter subscribes when attaching to the view. Interactor and Routing are, let's say, Preseters "tools", presenter delegates work to them and receives results using Observables. That said, there is no component that calls Presenters methods, so there is no need to make it implement any interface.

Ok, so let's begin implementing the Presenter. Let's check out what do we have there already.

```Java
class LoginPresenter :
        BaseRxPresenter<LoginContract.View,
                LoginContract.Interactor,
                LoginContract.Routing>(),
        ViperPresenter<LoginContract.View> {

    override fun createRouting() = LoginRouting()

    override fun createInteractor() = LoginInteractor()
}
```

As you can see, there are already declarations of routing and interactor generated by generator. You probably noticed that class declaration is pretty complicated because of some crazy generic stuff. Don't worry, after implementing some Viper modules you will get what happens here, but for now just trust the force (the generator, to be more specific) and begin with defining what shall happen on the very beginning of the presenter lifecycle in Viper module - on a presenter to view attach. To achieve that override the `attachView(view: LoginContract.View?)` method. Don't forget to call super!

```Java
class LoginPresenter :
        BaseRxPresenter<LoginContract.View,
                LoginContract.Interactor,
                LoginContract.Routing>(),
        ViperPresenter<LoginContract.View> {

    override fun attachView(view: LoginContract.View?) {
        super.attachView(view)

        addSubscription(
                view
                        ?.loginClicks
                        ?.doOnNext { view?.showLoading() }
                        ?.subscribeOn(Schedulers.io())
                        ?.flatMapSingle { interactor.performLogin(it) }
                        ?.observeOn(AndroidSchedulers.mainThread())
                        ?.doOnNext { routing.goToProfileScreen() }
                        ?.doOnError {
                            view?.hideLoading()
                            view?.showError(it)
                        }
                        ?.retry()
                        ?.subscribe())

        addSubscription(
                view
                        ?.helpClicks
                        ?.doOnNext { routing.goToHelpScreen() }
                        ?.doOnError { view?.showError(it) }
                        ?.retry()
                        ?.subscribe())
    }

    override fun createRouting() = LoginRouting()

    override fun createInteractor() = LoginInteractor()
}
```

As you probably noticed, presenter has an access to view, routing and interactor in whole class scope. Moreover, it automagically cast it to appropriate interface defined in contract. Note that I always use the view optional call - it's just easier to do it in a no-brainer way, as we often use thread switching in our streams, so view could get detached from the presenter in the meanwhile. Don't let Android Studio fool you using "unnecessary safe call" message! On the other hand Interactor and Routing are tightly coupled with presenter so there is no need to use safe calls on them in any situation. The other fancy thing there is that we haven't even touched the another components but we can safely implement whole presenter! Using Moviper you can pararelize work on the single module on whole team. Making work more focused on single screen makes you send new builds to QA faster, so there is no bottlenecking on the very end of the sprint! Now let's go back to the implementation. You're probably wondering why I do such stuff:

```Java

createSomeStream()
    ?.doOnNext { doStuffIWantOnTheEndOfStream() }
    ?.doOnError { handleError(it) }
    ?.retry()
    ?.subscribe()
```

instead of:

```Java

createSomeStream()
    ?.subscribe(
        { doStuffIWantOnTheEndOfStream() },
        { handleError(it) })
```

Now let's look at the Rx documentation:

!![image]

As you can see, after the error Observable finishes its lifecycle - it unsubscribes all its observers. We don't want this behaviour, as if user wants to log in and he's out of the Internet, he will get some error about it. Then, if he manages to get some network and retries this action, nothing will happen, as our Presenter unsubscribed from login button events. That's nasty. We don't want that, so that's why we use side-effect operators and retry. Actually, we could do it like this:

```Java

createSomeStream()
    ?.doOnError { handleError(it) }
    ?.retry()
    ?.subscribe { doStuffIWantOnTheEndOfStream() }
```

This will cause error in `doStuffIWantOnTheEndOfStream()` not to be passed to our doOnError and retry, what will lead to crash in RxJava 1.x and swallowing an error and unsubscribing in RxJava 2.x. Well, yeah, it looks like a long RxJava story is starting right now, so I'm going to stop and give you this official link ;) https://github.com/ReactiveX/RxJava/wiki/What's-different-in-2.0#error-handling . We could add some error handler to subscribe method to notify user about the error in the view (in our case) and ie close the screen or an app, but:
1. I don't want duplicating the error handling in such view.
2. Our production experience in Movibe / Wirtualna Polska shows that handling unexpected view errors in such way allows us to get rid of many annoying, exotic-device-specific crashes in ie. TextViews. I know that you got used to hearing that your app shall crash in unexpected scenarios but actually our user will get an "whoops, something went wrong" toast in such scenario and he can just tap the button once again, and in all of the cases of random errors we have seen it worked at the second time, what's much faster and more friendly to user than crashing, launching app again, navigating to given screen and putting all of the data there again. We report all of doOnError caught errors to Fabric anyway, so if something really doesn't work we will realize that quickly, and user can go on with using other app functionalities without being kicked out of the app. That's why we have introduced the `retrySubscribe(...)` method that allows you do it using one call:

```Java
fun <T> Observable<T>.retrySubscribe(onNext: (T) -> Unit,
                                     onError: (Throwable) -> Unit) =
        this.doOnNext(onNext)
                .doOnError(onError)
                .retry()
                .subscribe()!!
```

So let's replace the mentioned calls using this metod:

```Java
addSubscription(
        view
                ?.loginClicks
                ?.doOnNext { view?.showLoading() }
                ?.subscribeOn(Schedulers.io())
                ?.flatMapSingle { interactor.performLogin(it) }
                ?.observeOn(AndroidSchedulers.mainThread())
                ?.retrySubscribe(
                        { routing.goToProfileScreen() },
                        {
                            view?.hideLoading()
                            view?.showError(it)
                        }))


addSubscription(
        view
                ?.helpClicks
                ?.retrySubscribe(
                        { routing.goToHelpScreen() },
                        { view?.showError(it) }))
```

On the example you can see that each stream is wrapped in `addSubscription` call. It's one of the built-in Moviper methods that allows you forget about the need of unsubscribing your streams to avoid memory leaks. Just wrap all of your never completing streams using `addSubscription` and that's all! Your streams will be unsubscribed at presenter detach from View. If you have some properties in your presenter that need some special finishing, do it overriding `onDetach(Boolean retainInstance)` method (and once again, don't forget to call super!). But remember, not every call of it means that presenter will be destroyed - if a `retainInstance` argument is `true` it means that attached view is destroying because of the Android orientation change, and presenter will be retained and reattached to the new view, so you don't have to nuke your delegates (at least these which don't use the view reference). The thing worth emphasize here is that your presenter won't be parcelled and recreated or sth, it will be the same, exact presenter that have been attached to the view before orientation change. Moreover, all of the background work that the presenter performs (and all of its children, with Routing and Interactor as a most notable example of them) will be delivered to the eventual view if the orientation change happens in the meanwhile if you follow one rule of the thumb - *always communicate with the view using the main thread* (http://hannesdorfmann.com/mosby/summary/ - Can the Presenter and its view be out of sync during a screen orientation change?) even if view will need to perform some hard work on the background thread, using the diffUtil for example - always call the view on the main thread and delegate the work to another thread in the view itself. For more info about the presenter and view lifecycle and behaviour I recommend you reading the Mosby  http://hannesdorfmann.com/mosby/ docs and blog as the Moviper is built on top of this library, so it inherits the behaviour of view-presenter relations.

Ok, so we have discussed the Moviper behaviour in this context, so now let's focus on our sample app logic:

```Java
addSubscription(
        view
                ?.loginClicks
                ?.doOnNext { view?.showLoading() }
                ?.subscribeOn(Schedulers.io())
                ?.flatMapSingle { interactor.performLogin(it) }
                ?.observeOn(AndroidSchedulers.mainThread())
                ?.retrySubscribe(
                        { routing.goToProfileScreen() },
                        {
                            view?.hideLoading()
                            view?.showError(it)
                        }))
```
So let's see what happens here:
1. `addSubscription` call that wraps our stream to make sure that there won't be any memory leak
2. and
3. call on the loginClicks stream provided by our view what is defined in our contract
4. we show the loading on the view to notify the user about the processing of the request
5. delegation of the work to the background thread as it will be network based
6. delegation of the data work to the interactor using a method that is defined in our contract
7. we switch the thread back to the mainThread as in the methods below we will touch the UI
8. we call our special operator that will allow us to retry the calls in case of failure
9. if the interactor performed our request succesfully we delegate the screen switch action to the routing using a method that is defined in our contract
10.
11.
12.
13. if the request has failed we hide loading on the view and show the error to the user

The second stream based on `view?.helpClicks` has the similar philosophy, so I won't cover it step by step as it's pretty straightforward in the context of the previous stream.

OK, so our presenter is ready, now let's implement the routing. Let's start with using Android Studio auto-fix to implement stubbed methods from the contract:

```Java
class LoginRouting : BaseRxRouting<Activity>(), LoginContract.Routing {

    override fun goToHelpScreen() {
        TODO("not implemented")
    }

    override fun goToProfileScreen() {
        TODO("not implemented")
    }
}
```

To start these screens I will use starters here. Starter is a simple class that is used to, well, start the screens. But why to use them instead of just starting the activity here? There are two main reasons to do it:

1. We need to perform transitions to two screens in this screen. If we want to make these screens also VIPER-based, we will need to add six files (contract, Presenter, Interactor, View, Routing, layout) for each of them and insert appropriate lines to AndroidManifest, so that won't be really good in context of implementing only one screen.
2. If we want to TDD our screen (and we do, I will cover it on the next blog post) it's much easier to mock the context and check if appropriate starters were called than test if appropriate activities were started. Moreover, it's much quicker to do it using mocked context than to use Robolectric to test that activities were started.

So let's create starters for mentioned screens and place them in correct packages:

![I put the starters for the separate packages in the same way I did with a whole Login Viper module.]({{ site.url }}/assets/StartersLocation.png){:.center-image}
*I put the starters for the separate packages in the same way I did with a whole Login Viper module.*{: style="text-align: center; display: block;"}

Ok, so now let's use our starters in routing:

```Java
class LoginRouting : BaseRxRouting<Activity>(), LoginContract.Routing {

    private val helpStarter = HelpStarter()
    private val profileStarter = ProfileStarter()

    override fun goToHelpScreen() {
        relatedContext?.let { helpStarter.start(it) }
    }

    override fun goToProfileScreen() {
        relatedContext?.let { profileStarter.start(it) }
    }
}

```

And a quick look how the starters look like:

```Java
class HelpStarter {

    // it won't work for now as we don't have HelpActivity yet, so for now let's leave this method empty.
    fun start(context: Context) = context.startActivity(Intent(context, HelpActivity::class.java))
}
```

As you can see, I have made them fields of our Routing. You will get the great benefit of it in the next post, while we'll redo the whole process using TDD. For now just trust me please ;). Please take note of a `relatedContext` nullcheck using cool Kotlin [safe call](https://kotlinlang.org/docs/reference/null-safety.html#safe-calls) and [let function](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/let.html). In Routing it's important to always check if the mentioned context is attached, because if Presenter calls a routing on the non-main thread, it's possible that related context provider, ie. Activity already got destroyed, so it could lead to crash. Ok, so now we have implemented the routing despite that we don't have any other Viper module implemented, nice!

Ok, so let's implement the Interactor now, I did it that way:

```Java
class LoginInteractor : BaseRxInteractor(), LoginContract.Interactor {

    val retrofit = Retrofit.Builder().baseUrl("https://api.github.com/").build()

    override fun performLogin(loginBundle: LoginBundle): Single<UserModel> {
        return retrofit
                .create(LoginAndGetUser::class.java)
                .getUser(loginBundle.authorization)
    }

    private interface LoginAndGetUser {
        @GET("/user")
        fun getUser(@Header("Authorization") authorization: String): Single<UserModel>
    }
}
```

Where I have extended LoginBundleClass like this:

```Java
data class LoginBundle(val login: String,
                       val password: String){

    val authorization = "Basic " + Base64.encodeToString(("$login:$password").toByteArray(), Base64.NO_WRAP)
}
```

*Pro reader note: yep, I know how it looks like, but dude, it's for presentation purposes.*

Well, I don't want to focus on networking implementation here, it's over-simplified moreover. Just trust me, this code takes the login and password and translates it in the way readable for server authorization. In the regular case we would need to keep the header for whole session using Interceptors, and I personally would abstract-out the network layer implementation from the Interactor using Repository Design Pattern, but it's the material for another article anyway.

Now let's focus on the view implementation:

```Java
class LoginActivity : ViperAiPassiveActivity<LoginContract.View>(), LoginContract.View {

    override val loginClicks by lazy {
        RxView.clicks(loginBtn)
                .map {
                    LoginBundle(login = loginField.text.toString(),
                            password = passwordField.text.toString())
                }!!
    }

    override val helpClicks by lazy { RxView.clicks(helpBtn) }

    override fun showLoading() {
        progressBar.visible()
        loginBtn.gone()
    }

    override fun showError(error: Throwable) {
        progressBar.gone()
        loginBtn.visible()
        Toast.makeText(this, error.localizedMessage, Toast.LENGTH_SHORT).show()
    }

    override fun createPresenter() = LoginPresenter()

    override fun getLayoutId() = R.layout.activity_login
}
```

In this file I have used some cool Kotlin features to reduce boilerplate and make the code more readable. Firstly, there are [Kotlin Android Extensions](https://kotlinlang.org/docs/tutorials/android-plugin.html) that allows us reefer views using their ids directly in code without declaring them using `findViewById()` method. You can see that I reference progressBar, loginBtn etc directly, without any initialization. The second thing is the use of [Extension Functions](https://kotlinlang.org/docs/reference/extensions.html#extension-functions) that I use to change the visibility of the views neatly, ie `progresBar.visible()`. I put view extensions to the separate file in the `utils` package:

`com.mateuszkoslacz.movipershowcase.util.ViewExtensions.kt`
```Java
fun View.visible() {
    this.visibility = View.VISIBLE
}

fun View.gone() {
    this.visibility = View.GONE
}
```

The third thing is a usage of [Kotlin lazy function](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/lazy.html) that allows us to initialize values that uses Android Views inside the class body, before views initialization, instead of `onCreate` method. Kotlin is sweet!

I've also used [Jake Wharton's RxBinding](https://github.com/JakeWharton/RxBinding) to easily create Rx streams from buttons.

And don't forget about the corresponding layout file:

```xml
<android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
                                             xmlns:app="http://schemas.android.com/apk/res-auto"
                                             android:layout_width="match_parent"
                                             android:layout_height="match_parent">

    <EditText
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:inputType="textPersonName"
            android:ems="10"
            android:id="@+id/loginField"
            app:layout_constraintTop_toTopOf="parent"
            android:layout_marginTop="8dp"
            android:layout_marginRight="8dp"
            app:layout_constraintRight_toRightOf="parent"
            android:layout_marginLeft="8dp"
            app:layout_constraintLeft_toLeftOf="parent"
            android:hint="login"
            app:layout_constraintHorizontal_bias="0.503"/>

    <EditText
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:inputType="textPassword"
            android:ems="10"
            android:id="@+id/passwordField"
            android:layout_marginTop="8dp"
            app:layout_constraintTop_toBottomOf="@+id/loginField"
            android:layout_marginRight="8dp"
            app:layout_constraintRight_toRightOf="parent"
            android:layout_marginLeft="8dp"
            app:layout_constraintLeft_toLeftOf="parent"
            android:hint="password"/>

    <Button
            android:text="Login"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:id="@+id/loginBtn"
            android:layout_marginRight="8dp"
            app:layout_constraintRight_toRightOf="parent"
            android:layout_marginLeft="8dp"
            app:layout_constraintLeft_toLeftOf="parent"
            android:layout_marginTop="8dp"
            app:layout_constraintTop_toBottomOf="@+id/passwordField"/>

    <ProgressBar
            style="?android:attr/progressBarStyle"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:id="@+id/progressBar"
            android:layout_marginRight="8dp"
            app:layout_constraintRight_toRightOf="parent"
            android:layout_marginLeft="8dp"
            app:layout_constraintLeft_toLeftOf="parent"
            app:layout_constraintTop_toTopOf="@+id/loginBtn"
            android:layout_marginTop="8dp"
            android:visibility="gone"/>

    <Button
            android:text="help"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:id="@+id/helpBtn"
            android:layout_marginRight="8dp"
            app:layout_constraintRight_toRightOf="parent"
            android:layout_marginLeft="8dp"
            app:layout_constraintLeft_toLeftOf="parent"
            app:layout_constraintBottom_toBottomOf="parent"
            android:layout_marginBottom="8dp"/>
</android.support.constraint.ConstraintLayout>
```

![This is how our view looks like.]({{ site.url }}/assets/MainActivityLayout.png){:.center-image}
*This is how our view looks like.*{: style="text-align: center; display: block;"}

As you can see, our view implementation is pretty straightforward. We show and hide appropriate views, show an error in the toast, and provide click streams - in case of login clicks, we map it to the `LoginBundle` using text from inputs. There is also a defined presenter and layout, and that was done for us by MoviperTemplatesGenerator. In the view you just define the behaviour, layout, and a presenter, and you don't have to worry about any kind of binding to presenter, handling lifecycle etc. Moviper does it for you.

It's worth noting that view is 100% passive here - it means that view is not aware of kind of presenter attached to it nor methods it has. It doesn't call presenter in any way - it just provides the interface to which some presenter can attach itself to. It's presenter that decides what to do, what to use and what not to use - view has no app logic inside. First of all, it's a clean design that makes our apps maintainable, but it also comes in handy in our production environment where we attach multiple presenters to our views using Moviper [ViperPresentersList](https://github.com/mkoslacz/Moviper#attaching-multiple-presenters-to-the-view) presenter class; app logic presenter, analytics presenter, advertising presenter, and the count of the presenters is transparent for the view. It allows us dynamically attach or detach presenters to ie turn off ads for premium users. Moreover, if your presenter has grown too much and for some reason you can't split your view to smaller chunks that corresponds with separate usecases you can create the presenter for each usecase and attach the whole bunch of them to the single view. It allows us to keep our classes small, and smaller (in most cases) means more readable, more maintainable, more testable and more awesome. And still - with no changes to View!

Ok, now our login screen is fully functional. But before launching it let's pretend that our sprint have just finished and we have to implement the next screens. Let's check out how it will influence our previous module (hint: it won't).

Let's create our HelpActivity that we're prepared to launch as we have created a starter for it before. It's not created as a Moviper Activity for simplicity, but it should be ;):

```Java
class HelpActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_help)
    }
}
```

and now we can uncomment the code we wrote before in our starter:

```Java
class HelpStarter {

    fun start(context: Context) = context.startActivity(Intent(context, HelpActivity::class.java))
}
```

What are the changes in the Login Viper code? None. The only difference is that our help button started to work. In Login Viper, what will be a overhead of an existence of a help screen if we decide to disable the help button using some remote config? Almost none (a one-liner HelpStarter class object created in Routing). Moreover, we could remotely swap the starter to another one existing in our code to remotely modify the behavior of the app. Viper allows a very high modularity of apps in the level that allows to reconfigure the app on the fly. It's very helpful in handling special events (ie. special Christmas modules that can be activated and deactivated without an update) or some fatal scenarios in which some module malfunctions we can always disable it remotely to avoid further crashes during the hotfixing. More detailed article about this feature coming soon.

Now let's focus on the ProfileActivity, and once again,  we're prepared to launch it as we have created a starter for it before. It's not created as a Moviper Activity for simplicity, but it should be ;):

```Java
const val EXTRA_USERNAME_STRING = "EXTRA_USERNAME_STRING"

class ProfileStarter {

    fun start(context: Context, user: UserModel) {
        val starter = Intent(context, ProfileActivity::class.java)
        starter.putExtra(EXTRA_USERNAME_STRING, user.login)
        context.startActivity(starter)
    }

}
```

```Java
class ProfileActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_profile)
        usernameText.text = intent.getStringExtra(EXTRA_USERNAME_STRING)
    }
}
```

And once again, no changes in Login Viper code, and the only difference is that we're processed to the ProfileScreen after the successfull login.
