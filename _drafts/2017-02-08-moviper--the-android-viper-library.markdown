---
layout: post
title: "Moviper - the Android VIPER Library"
date: "2017-02-08 08:38:09 +0100"
---

#tl;dr


On the previous post I have covered pros and cons and a general idea of the viper architecture. For now let's focus on Moviper - the Android Viper library. Moviper comes in many different flavors, you can choose more or less advanced one or just pick one that fits you most. In this post I'll show you the flavor I use in the daily basis on the example of a simple Github login screen. I use Rx Presenters, Passive Autoinject Views and I wrap it up using Kotlin language with Android Kotlin Extensions. Sounds scary? Actually it's pretty straighforward. Fear not and read on!

We are going to create very simple app, that will allow a user to log in to Github and go to the fake profile page, and provide info about the app.

INSERT SOME SCREENSHOTS

It will consist of login screen that:
- allows user to go to the help screen,
- lead to profile page after login.

Ok, enough talking, let's get our feet wet!

First of all, install the [Moviper Templates Generator](https://github.com/mkoslacz/MoviperTemplateGenerator) using instructions provided in the repos readme. Just click the link I've inlined. Remember to restart the Android Studio after the installation!

After that, start up with a brand new Android project with no Activity. If you're new to Android you can follow a official Google tutorial [here](https://developer.android.com/studio/projects/create-project.html) to learn more about stuff we will discuss here.

The next step is pretty obvious, go to [Moviper Github page](https://github.com/mkoslacz/Moviper) and find the latest Moviper version and import its dependency adding following line to app module gradle dependencies and sync the project.

```(groovy)
dependencies {
  compile 'com.mateuszkoslacz.moviper:moviper-rx:2.0.1'
}
```

Now things get interesting. Let's create our first Viper Activity! Right-click the app package and select New -> Moviper -> RxActivity (see attached screen). Pro tip: you can even assign a shortcut to creating any of the Moviper modules using *Manage shortcuts* menu (easy to find using our standard cmd/ctrl + shift + A magic) and searching for "moviper" actions. That will be even more smooth using the great [Key Promoter](https://plugins.jetbrains.com/plugin/4455-key-promoter) plugin, it will suggest you assigning a shortcut to the most used actions, you should definitely check it out. Pro tip: search for "plugins" menu using cmd shift a, and just search for this plugin there!

![This is where lies RxActivity generator.]({{ site.url }}/assets/chosingViperRxActivity.jpg){:.center-image}
*This is where lies RxActivity generator.*{: style="text-align: center; display: block;"}

![Assigning shortcuts for Moviper actions will definitely come in handy.]({{ site.url }}/assets/assigningShortcutsToMoviper.jpg){:.center-image}
*Assigning shortcuts for Moviper actions will definitely come in handy.*{: style="text-align: center; display: block;"}

Fill up the form like I did on the attached image: name it LoginActivity, mark it as a Launcher Activity and select Passive Autoinject type. There are some magic options there, but just trust me for now - I'll cover them later. After confirming that choice we land in the Contract class. It generally has the one purpose - it defines whole control and data flow in the given screen. At your left hand side, on the project overview, you can see the rest of the classes generated by plugin in \*.viper.login package. Viper is general package for viper modules, and login was inferred from the name we gave to the generated Activity. But hold on - I told you that we will make a Kotlin app, and these files feel somehow suspicious. Yep, MoviperTemplateGenerator creates only Java file sets and actually there is no plan to migrate it to Kotlin, as this way we can use it in the Java code, and for Kotlin apps we can convert it to Kotlin very easy, so let's do it right now using magic alt + cmd + shift + K shortcut in each of generated classes.

For now we have a set of 5 Kotlin files:

- LoginActivity class (the view)
- LoginContract interface
- LoginInteractor class
- LoginPresenter class
- LoginRouting class

It's a good time to stop now and discuss the responsibility distribution over these components. In a classical objc-viper we have a following division:

>The main parts of VIPER are:
>
>View: displays what it is told to by the Presenter and relays user input back to the Presenter.
>Interactor: contains the business logic as specified by a use case.
>Presenter: contains view logic for preparing content for display (as received from the Interactor) and for reacting to user inputs (by requesting new data from the Interactor).
>Entity: contains basic model objects used by the Interactor.
>Routing: contains navigation logic for describing which screens are shown in which order.

But in our team we have worked out the following, slightly shifted responsibility fragmentation:

- View: displays what it is told to by the Presenter and relays user input back to the Presenter. (exactly the same as above)
- Interactor: contains the data read/write logic - all of the api and db calls go here.
- Presenter: contains the buisness logic: reacts to user input, ie translating to interactor and routing calls, decides what to display on view, validates the data in the business sense.
- Entity: data objects that are used in the app buisness logic, independent from data handling and view implementation
- Routing: contains all system-related logic. You can alternatively call it "System". It manages navigation, screen transitions, scheduling notifications, etc.

Mentioned division allows us to create modular, testable, clean and neat code. So, if we have
